This project contains interpreters for the programming languages *Loop, Goto
& While* that are based on [Prof Dr. Heribert Vollmer][vollmer]'s lecture notes
for his introductory course in theoretical computer science. They are modeled
to feel similar to common imperative programming languages but they are
delibaretly greatly simplified. Furthermore, when possible, functions to
transform source code from one language to another are provided, too.

  [vollmer]: http://www.thi.uni-hannover.de/en/homepage/people/heribert-vollmer/

I created a [live web evaluation service][evalservice] where you can write some
code and have it either evaluated or transformed. Additionally, to keep
yourself entertained, you can find some exercises on that website, too.

  [evalservice]: http://loopgotowhile.eugenkiss.com/

Execute `runtests.sh` to run the tests.


Background
----------

The purpose of these languages in Prof Dr. Heribert Vollmer's introductory
course in theoretical computer science was to provide formal semantics for the
specification of algorithms. Moreover, the languages were used to show the
equivalence of turing complete languages. There was no executable
implementation of these languages to my knowledge. Frankly, why should there
have been? Their purpose didn't require that. However, I thought it would be an
interesting exercise to create exectuable implementations for these languages.
Even more so as I always wanted to create an executable implementation of
a programming language and it was the perfect opportunity to get to know
Haskell better.

Most of all, I wanted to see how elegantly the problem of creating parsers,
evaluators and "transformators" for these languages could be expressed in
Haskell. And I'm quote pleased with the result although I acknowledge that
there is much to improve especially regarding the code duplication for
transforming each language to its strict subset. 


Design of the Code
------------------

In reality there aren't three languages but six; each language is given in
a strict and extended version. When being evaluated a language is first
transformed into its strict subset - as it is easier to write an evaluator for
the strict subset - and only then (indirectly) evaluated.

Only strict Goto and strict While are evaluated directly. Loop is evaluated by
first transforming it to While and then evaluating that While program. Although
it would suffice to only have one directly evaluated language this is not done
due to performance reasons. It is much faster to directly evaluate Goto as
opposed to evaluating Goto through While.

Shared functionality is outsourced to the "Shared" namespace in order to reduce
code duplication and thus reuse more code.

I know that much can be improved. If you have suggestions then contact me,
please.

*Note*: Some of the "to-strict-transformation"-tests don't use a hand-written
strict program to test the transformations against but instead they test
against a simplified extended program that is automatically transformed to
a strict program. The reason for this decision is that a strict program would
simply be too long and too convoluted to comprehend the applied
transformations. Nonetheless, these tests are not useless as the preceding,
more primitive tests "ensure" that the transformations of the simplified
extended version to a strict version will be correct.



Future Improvements
-------------------

### Code/Style Improvements

- Remove code duplication especially regarding the code duplication for
  transforming each language to its strict subset. Also, try to reduce
  code duplication for While & Goto evaluation
- Some parts are quite ugly (see TODO's in the source code). Beautify!
- Customization of Error Messages in Parsec leaves much to be desired.
- Improve output of pretty printers (e.g. dismiss superfluous parentheses)


### Feature Additions

- Function Definitions

- Command line tools for each language
    - Options
        - -p, --prettyprint 
        - -s, --strict
        - -t [loop,goto,while], --transform [loop,goto,while] (list only those that are possible)
        - -o, --output (default: stdout)
    - Extract common functionality to Shared
    - Create executables in cabal

- Optimizations
    - Create benchmark suite
    - Remove redundancy (e.g. remove `x0 := x0 + 0`) (already happened to Goto)
    - Possibly improve efficiency of arithmetic functions (e.g. is / reduction
      to strict code efficient or is it possible to make the algorithm faster)
    - Other optimizations? Loop invariants?


### Tests

Test duplication/redundancy could be greatly reduced if at first code
duplication is reduced. This way, tests could be reused on the one hand and on
the other hand a lot of "to-strict-transformation" tests for While and Goto
could be removed since it would suffice to test Loop's
"to-strict-transformations" thouroughly if all languages shared (almost) the
same code. 


Language Specifications
-----------------------

You can only implement functions whose codomain are the natural numbers and
whose domain are the natural numbers to the power of *n*, where *n* is the
number of arguments. Also, every variable is by default initialized to `0` and
arguments, if any, are stored in `x1,...,xn`. That means, providing the
argument list `4,87,3` is the same as prepending `x1 := 4; x2 := 87, x3 := 3`
to the top of your program.


### Loop

#### Syntax

#### Sematics

#### Extensions


### Goto

#### Syntax

#### Sematics

The behaviour for using an unspecified label in a GOTO statement is undefined.

#### Extensions

optional labels, can be named like identifiers,
HALT can come inside if body, rest like loope


### While

#### Syntax

#### Sematics

#### Extensions

while head can have bexp, rest like loope
